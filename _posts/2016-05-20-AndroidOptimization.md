---
title: "Android性能优化总结"
tags: [Android]
---

前阵子准备客户端开发的面试，对Android的性能优化进行了比较系统的复习，在这里做一下总结与回顾，主要针对UI性能优化和内存性能优化两方面展开。

## UI 性能优化

### 应用卡顿原理
- 人类大脑与眼睛对一个画面的连贯性感知其实是有一个界限的，譬如我们看电影会觉得画面很自然连贯（帧率为24fps），用手机当然也需要感知屏幕操作的连贯性（尤其是动画过度），所以Android索性就把达到这种流畅的帧率规定为60fps。

- 换算关系：60帧/秒-----------16ms/帧；  
准则：尽量保证每次在16ms内处理完所有的CPU与GPU计算、绘制、渲染等操作，否则会造成丢帧卡顿问题。

- 针对Android系统的设计我们还需要知道另一个常识；虚拟机在执行GC垃圾回收操作时所有线程（包括UI线程）都需要暂停，当GC垃圾回收完成之后所有线程才能够继续执行（这个细节下面小节会有详细介绍）。也就是说当在16ms内进行渲染等操作时如果刚好遇上大量GC操作则会导致渲染时间明显不足，也就从而导致了丢帧卡顿问题。

### 应用卡顿原因
- 人为在UI线程中做轻微耗时操作，导致UI线程卡顿；
- 布局Layout过于复杂，无法在16ms内完成渲染；
- 同一时间动画执行的次数过多，导致CPU或GPU负载过重；
- View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；
- View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；
- 内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；
- 冗余资源及逻辑等导致加载和执行缓慢；
- 臭名昭著的ANR；

### GC导致的卡顿
触发垃圾回收的主要原因有以下几种：

- GC_MALLOC——内存分配失败时触发；
- GC_CONCURRENT——当分配的对象大小超过一个限定值（不同系统）时触发；
- GC_EXPLICIT——对垃圾收集的显式调用(System.gc()) ；
- GC_EXTERNAL_ALLOC——外部内存分配失败时触发；

可以看见，这种不停的大面积打印GC导致所有线程暂停的操作必定会导致UI视觉的卡顿，所以我们要避免此类问题的出现，具体的常见优化方式如下：

- 检查代码，尽量避免有些频繁触发的逻辑方法中存在大量对象分配；
- 尽量避免在多次for循环中频繁分配对象；
- 避免在自定义View的onDraw()方法中执行复杂的操作及创建对象（譬如Paint的实例化操作不要写在onDraw()方法中等）；
- 对于并发下载等类似逻辑的实现尽量避免多次创建线程对象，而是交给线程池处理。

### ANR

ANR（Application Not Responding）是Android中AMS与WMS监测应用响应超时的表现；之所以把臭名昭著的ANR单独作为UI性能卡顿的分析来说明是因为ANR是直接卡死UI不动且必须要解掉的Bug，我们必须尽量在开发时避免他的出现。

我们应用开发中常见的ANR主要有如下几类：

- 按键触摸事件派发超时ANR，一般阈值为5s（设置中开启ANR弹窗，默认有事件派发才会触发弹框ANR）；
- 广播阻塞ANR，一般阈值为10s（设置中开启ANR弹窗，默认不弹框，只有log提示）；
- 服务超时ANR，一般阈值为20s（设置中开启ANR弹窗，默认不弹框，只有log提示）；

### UI优化方法总结
具体项目中常见的注意事项如下：

- 布局优化；尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局（譬如10层就会直接异常），尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。
- 列表及Adapter优化；尽量复用getView方法中的相关View，不重复获取实例导致卡顿，列表尽量在滑动过程中不进行UI元素刷新等。
- 背景和图片等内存分配优化；尽量减少不必要的背景设置，图片尽量压缩处理显示，尽量避免频繁内存抖动等问题出现。
- 自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法中，尽量减少draw、measure、layout等执行次数。
- 避免ANR，不要在UI线程中做耗时操作，遵守ANR规避守则，譬如多次数据库操作等。

## 内存性能优化
### Android系统级内存管理
- Android系统级内存管理机制类似于Java的垃圾回收机制，在Android系统中框架会定义如下几类进程，在系统内存达到规定的阈值时会触发清空不同level的进程类型：
    - 前台进程
    - 可见进程
    - 桌面进程
    - 次要服务进程
    - 后台进程
    - 内容供应节点进程
    - 空进程

### 内存泄漏性能分析
- 内存泄漏概念
    - 在对象的生命周期本来该被垃圾回收时这个对象还被别的对象持有引用，就会导致内存泄漏。
    - 后果：随着我们的应用被长时间使用，他所占用的内存越来越大

举个例子：让一个单例模式的对象持有了当前Activity的强引用，那在当前Acvitivy执行完onDestroy()后，这个Activity就无法得到垃圾回收，也就造成了内存泄露。

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.activity_main);  
        //DbManager是一个单例模式类，这样就持有了MainActivity引用，导致泄露
        mDbManager = DbManager.getInstance(this);    
    }   


- 内存泄漏导致问题
    - 应用卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）;
    - 应用被从后台进程干为空进程（上面系统内存原理有介绍，也就是超过了阈值）；
    - 应用莫名的崩溃（上面应用内存原理有介绍，也就是超过了阈值OOM）；
- 常见的规避内存泄漏建议
    - Context使用不当造成内存泄露；不要对一个Activity Context保持长生命周期的引用（譬如上面概念部分给出的示例）。尽量在一切可以使用应用ApplicationContext代替Context的地方进行替换（原理我前面有一篇关于Context的文章有解释）。
    - 非静态内部类的静态实例容易造成内存泄漏；即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。
    - 警惕线程未终止造成的内存泄露；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是HandlerThread的run方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运thread.getLooper().quit();才不会泄露。
    - 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。
    - 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。
    - 不要在执行频率很高的方法或者循环中创建对象，可以使用HashTable等创建一组对象容器从容器中取那些对象，而不用每次new与释放。
    - 避免代码设计模式的错误造成内存泄露；譬如循环引用，A持有B，B持有C，C持有A，这样的设计谁都得不到释放。

### 内存溢出性能分析

- 内存溢出的主要导致原因有如下几类：
    - 应用代码存在内存泄露，长时间积累无法释放导致OOM；
    - 应用的某些逻辑操作疯狂的消耗掉大量内存（譬如加载一张不经过处理的超大超高清图片等）导致超过阈值OOM；  
- 无论哪种类型，导致内存溢出（OutOfMemoryError）的核心原因就是应用的内存超过阈值了。
- 常见的规避内存溢出建议
    - 时刻记得不要加载过大的Bitmap对象；譬如对于类似图片加载我们要通过BitmapFactory.Options设置图片的一些采样比率和复用等，具体做法点我参考官方文档，不过过我们一般都用fresco或Glide开源库进行加载。
    - 优化界面交互过程中频繁的内存使用；譬如在列表等操作中只加载可见区域的Bitmap、滑动时不加载、停止滑动后再开始加载。
    - 有些地方避免使用强引用，替换为弱引用等操作。
    - 避免各种内存泄露的存在导致OOM。
    - 对批量加载等操作进行缓存设计，譬如列表图片显示，Adapter的convertView缓存等。
    - 尽可能的复用资源；譬如系统本身有很多字符串、颜色、图片、动画、样式以及简单布局等资源可供我们直接使用，我们自己也要尽量复用style等资源达到节约内存。
    - 对于有缓存等存在的应用尽量实现onLowMemory()和onTrimMemory()方法。
    - 尽量使用线程池替代多线程操作，这样可以节约内存及CPU占用率。
    - 尽量管理好自己的Service、Thread等后台的生命周期，不要浪费内存占用。
    - 尽可能的不要使用依赖注入，中看不中用。
    - 尽量在做一些大内存分配等可疑内存操作时进行try catch操作，避免不必要的应用闪退。
    - 尽量的优化自己的代码，减少冗余，进行编译打包等优化对齐处理，避免类加载时浪费内存。
